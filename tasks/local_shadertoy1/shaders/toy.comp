#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

layout(push_constant) uniform pushed_params 
{
  uint resolution_x;
  uint resolution_y;
  float time;
  float mouse_x;
  float mouse_y;
} pushed_params_t;

float iTime;
vec2 iResolution;
vec2 iMouse;



#define MAX_STEPS 500
#define MAX_DIST 50.0 
#define EPS 0.001
#define SMOOTH_FACTOR 0.03
#define FRAME_LENGTH 0.075
#define DELAY_TIME 3.0

mat3 rotateY(float al) 
{
    float c = cos(al);
    float s = sin(al);
    return mat3(
        vec3( c,0,s),
        vec3( 0,1,0),
        vec3(-s,0,c)
    );
}


float sMin(float a, float b, float k)
{
    // sigmoid
    k *= log(2.0);
    float x = b - a;
    return a + x/(1.0-exp2(x/k));
}


float sdBoxFrame(vec3 pos, vec3 b, float e ) 
{
       pos = abs(pos  )-b;
  vec3 q = abs(pos+e)-e;
  return min(min(
      length(max(vec3(pos.x,q.y,  q.z),0.0))+  min(max(pos.x,max(q.y,  q.z)),  0.0),
      length(max(vec3(q.x,  pos.y,q.z),0.0))+  min(max(q.x,  max(pos.y,q.z)),  0.0)),
      length(max(vec3(q.x,  q.y,  pos.z),0.0))+min(max(q.x  ,max(q.y,  pos.z)),0.0));
}

float sdPlane(vec3 p) 
{
    return p.y;
}



float buildScene(vec3 p, float time, mat3 m) 
{
     p = m * p;
    float distPlane = sdPlane(p);
    
    vec3 offset;
    if (time >= DELAY_TIME) 
    {
        time -= DELAY_TIME;
        offset = vec3(0, 0.7 + 1.5 * sin(time), 0);
    } else 
    {
        offset = vec3((DELAY_TIME-time) * 2.0, 0.7, 0);
    }
    float distBoxFrame = sdBoxFrame(p - offset, vec3(0.5, 0.7, 0.4), FRAME_LENGTH);
    return sMin(distPlane, distBoxFrame, SMOOTH_FACTOR);
}



float trace(vec3 from, vec3 dir, float time, out bool hit, in mat3 m) 
{
    hit = false;
    
    float dist = 0.0;
    for (int i = 0; i < MAX_STEPS; ++i) 
    {
        vec3 p = from + dir * dist;
        float d = buildScene(p, time, m);
        if (d < EPS )
        {
            hit = true; 
            return dist;
        }
        
        dist += d;
        if (dist > MAX_DIST)
        {
            break;
        }
    }
    
    return MAX_DIST;
}


vec3 generateNormal(vec3 p, float time, mat3 m) 
{
    float e = EPS;
    
    float dx1 = buildScene(p + vec3(e, 0, 0), time, m);
    float dx2 = buildScene(p - vec3(e, 0, 0), time, m);
    float dy1 = buildScene(p + vec3(0, e, 0), time, m);
    float dy2 = buildScene(p - vec3(0, e, 0), time, m);
    float dz1 = buildScene(p + vec3(0, 0, e), time, m);
    float dz2 = buildScene(p - vec3(0, 0, e), time, m);
    
    return normalize(vec3(dx1 - dx2, dy1 - dy2, dz1 - dz2));
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec4 color = vec4(0.0);
    bool hit;
    
    float time = iTime;
    
    vec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5, 0.0);
    mat3 m = rotateY(6.0 * mouse.x);
    
    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;
    uv.y = -uv.y;
    vec3 light = vec3(-1.0, 3.0, 1.0);
    vec3 eye = vec3(0.0, 1.0, 5.0);
    vec3 dir = normalize(vec3(uv, -1.0));
    
    float dist = trace(eye, dir, time, hit, m);
    if (hit) 
    {
        vec3 p = eye + dir * dist;
        vec3 n = generateNormal(p, time, m);
        vec3 l = normalize(light - p);
        float nl = max(0.0, dot(l, n));
        
        vec3 v = normalize(eye - p);
        vec3 h = normalize(v + l);
        float sp = pow(max(0.0, dot(n, h)), 50.0);
        
        vec4 colorW = vec4(1.0, 0.7, 0.3, 1);
        color = 0.5* (nl + sp) * colorW;
        
    }
    fragColor = vec4(color);
}

void main()
{
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

  iResolution = vec2(pushed_params_t.resolution_x, pushed_params_t.resolution_y);
  iTime = pushed_params_t.time;
  iMouse = vec2(pushed_params_t.mouse_x, pushed_params_t.mouse_y);

  vec4 fragColor;
  vec2 fragCoord = vec2(gl_GlobalInvocationID.xy);
  mainImage(fragColor, fragCoord);

  if (uv.x < pushed_params_t.resolution_x && uv.y < pushed_params_t.resolution_y)
    imageStore(resultImage, uv, fragColor);
}
